---
tags:
  - flashcards
---

В чём разница между типами и интерфейсами в TypeScript.?
????
##### Интерфейсы можно объединять и наследовать, тогда как типы не объединяются и лучше подходят для примитивов и утилити, но могут комбинироваться с помощью `&`, при этом перезаписывая совпадающие поля
;;;;

В чем отличие стрелочной функции от функционального декларирования.?
????
Cтрелочные функции не имеют собственного this (берут из лексического окружения), не имеют arguments, не могут быть конструкторами (new).   Имеют краткий синтаксис
;;;;

В чем преимущества и недостатки микрофронтендов. Как бороться с недостатками.?
????
###### Микрофронтенды — это архитектурный подход, при котором веб-приложение разбивается на независимые куски. Каждая команда может работать над своей частью интерфейса, используя разные технологии.
###### Преимущества микрофронтендов:

- **Модульность**: Позволяет командам работать независимо над различными частями приложения.
- **Гибкость технологий**: Возможность выбора разных технологий и фреймворков для каждой части.
- **Ускорение разработки**: Команды могут разрабатывать функции параллельно без зависимости друг от друга.
- **Постепенные обновления**: Можно обновлять части приложения поэтапно.

###### Недостатки:

- **Сложность интеграции**: Могут возникать проблемы с совместимостью между микрофронтендами.
- **Производительность**: Большое количество ресурсов может замедлить загрузку страницы.
- **Трудности с тестированием**: Необходимо протестировать взаимодействие всех частей.
- **Увеличенные затраты на DevOps**: Требуется больше усилий для настройки инфраструктуры.

###### Как бороться с недостатками:

- **Стандартизация**: Введение общих стандартов разработки и интеграции.
- **Оптимизация загрузки**: Использование lazy loading и других методов для улучшения производительности.
- **Автоматизация тестирования**: Настройка CI/CD для автоматического тестирования микрофронтендов.
- **Документация**: Поддержание актуальной документации и проведение обучений для команд.
;;;;

Для чего атрибуты async и defer в теге script.?
????
Атрибут `async` загружает и выполняет скрипты параллельно сразу после их загрузки, без ожидания завершения парсинга HTML, тогда как `defer` загружает скрипты асинхронно, но выполняет их только после завершения парсинга HTML в порядке их появления.
;;;;

Для чего используется Local Storage. Примеры?
????
Local Storage хранит данные в браузере (ключ-значение, текст, до ~10 МБ). Используется для сохранения данных между вкладками
;;;;

Для чего нужен Next.js, зачем его выбирать.?
????
**Next.js** — это фреймворк для React, который предоставляет множество преимуществ:

1. **SEO**: Next.js поддерживает серверный рендеринг, что улучшает индексацию страниц поисковыми системами и способствует лучшему SEO.
2. **Серверный рендеринг и статическая генерация**: позволяет генерировать HTML на сервере, что увеличивает скорость загрузки страниц и оптимизирует производительность для высоконагруженных сайтов.
3. **Удобная работа с метаданными**: простое управление заголовками и метаданными страниц, что улучшает пользовательский опыт.
4. **Автоматическая оптимизация**: Next.js автоматически оптимизирует контент, что позволяет быстрее загружать страницы и улучшает взаимодействие с пользователем.
;;;;

Для чего нужны call, bind, apply. Чем отличаются.?
????
Используются для изменения контекста (this) функции. bind создает новую функцию с заданным контекстом и аргументами. call и apply вызывают функцию сразу, но call принимает аргументы по одному, а apply — массивом.
;;;;

Зачем нужен хук useId.?
????
Хук `useId` полезен для создания уникальных идентификаторов, которые гарантируют согласованность между сервером и клиентом, способствуют доступности и упрощают код.
;;;;

Зачем придумали CORS.?
????
##### CORS, или Cross-Origin Resource Sharing, — это механизм, который позволяет контролировать доступ к ресурсам на сервере с других доменов.

Когда веб-приложение на одном домене пытается запросить данные с другого домена, браузер блокирует этот запрос для безопасности. CORS позволяет серверу указать, какие домены могут получать доступ к его ресурсам, добавляя специальные заголовки к ответам.

Например, если ваш сайт на `example.com` хочет получить данные с `api.example.com`, сервер API должен добавить заголовок `Access-Control-Allow-Origin`, чтобы разрешить такой доступ. Это помогает защитить данные и предотвратить атаки.

 
 ##### Вот основные заголовки, используемые в CORS:

1. **`Access-Control-Allow-Origin`**:
    
    - Указывает, какие домены имеют доступ к ресурсам.
    - Примеры:
        - `Access-Control-Allow-Origin: *` (разрешает доступ с любого домена)
        - `Access-Control-Allow-Origin: https://example.com` (разрешает доступ только с `example.com`)
2. **`Access-Control-Allow-Methods`**:
    
    - Указывает, какие HTTP-методы разрешены для кросс-доменных запросов.
    - Пример:
        - `Access-Control-Allow-Methods: GET, POST, PUT, DELETE`
3. **`Access-Control-Allow-Headers`**:
    
    - Указывает, какие заголовки могут быть использованы в запросе.
    - Пример:
        - `Access-Control-Allow-Headers: Content-Type, Authorization`
4. **`Access-Control-Allow-Credentials`**:
    
    - Указывает, можно ли отправлять учетные данные (например, куки) с запросом.
    - Пример:
        - `Access-Control-Allow-Credentials: true`
5. **`Access-Control-Expose-Headers`**:
    
    - Указывает, какие заголовки могут быть доступны клиенту в ответе.
    - Пример:
        - `Access-Control-Expose-Headers: X-Custom-Header`
6. **`Access-Control-Max-Age`**:
    
    - Указывает, как долго браузер может кешировать результаты preflight-запроса.
    - Пример:
        - `Access-Control-Max-Age: 3600` (1 час)



##### Почему CORS не работает в Postman? Postman не является веб-браузером, а представляет собой инструмент для тестирования API. Поскольку запросы в Postman выполняются от имени разработчика и не требуют пользовательской аутентификации в браузере
;;;;

Знаком ли с Chakra UI.?
????

;;;;

Знаком ли ты с TypeScript.?
????
**TypeScript** — это надстройка над JavaScript, разработанная компанией Microsoft, которая добавляет статическую типизацию к языку. Основные особенности TypeScript:

1. **Статическая типизация**: TypeScript позволяет задавать типы данных для переменных, функций, параметров и возвращаемых значений. Это помогает выявлять ошибки на этапе компиляции, а не во время выполнения.
    
2. **Совместимость с JavaScript**: TypeScript является суперклассом JavaScript, что означает, что любой корректный код JavaScript является также корректным кодом TypeScript. TypeScript компилируется в JavaScript, чтобы его можно было запускать в любых средах, поддерживающих JavaScript.
    
3. **Поддержка современных возможностей ECMAScript**: TypeScript поддерживает последние стандарты JavaScript, такие как деструктуризация, стрелочные функции и асинхронные функции, а также добавляет свои собственные возможности.
    
4. **Инструменты для разработки**: TypeScript предоставляет улучшенные возможности для IDE и текстовых редакторов, такие как автодополнение, навигация по коду и рефакторинг, что делает разработку более продуктивной.
    
5. **Модули и пространства имен**: TypeScript поддерживает использование модулей и пространств имен, что помогает организовывать код и управлять зависимостями.
;;;;

Как выглядит поток данных в Redux.?
????
Экшен диспатчится, попадает в редьюсер по типу, обновляет глобальный стор. Данные из стора используются в компонентах для рендера.
;;;;

Как оптимизировать перерендеры в React.?
????
##### Мемоизация (useMemo, useCallback, React.memo), ленивая загрузка (lazy), пагинация, троттлинг/дебонсинг, разделение компонентов, кэширование, виртуализация.
;;;;

Как применить принцип единой ответственности в React.?
????
**Принцип единой ответственности** в React применяется путем создания компонентов, которые выполняют одну конкретную задачу. Например:

- Создайте отдельные компоненты для кнопок, инпутов, списков и т.д.
- Делите более сложные компоненты на мелкие, которые легко тестировать и переиспользовать.

Таким образом, каждый компонент будет отвечать за свою часть интерфейса, что упрощает поддержку и развитие приложения.
;;;;

Как происходит загрузка страницы от ввода URL до рендера.?
????
##### Браузер получает IP-адрес через кэш или DNS, устанавливает соединение с помощью TCP-тройного рукопожатия, запрашивает `index.html`, парсит HTML и CSS в DOM и CSSOM, строит Render Tree, выполняет layout, окрашивает элементы и объединяет слои, при этом скрипты блокируют парсинг, а CSS — рендеринг, с атрибутами `async` и `defer` для управления загрузкой скриптов.
;;;;

Как происходит процесс от ввода URL до отображения страницы в браузере.?
????
Браузер получает IP-адрес через кэш или DNS, устанавливает соединение с помощью TCP-тройного рукопожатия, запрашивает `index.html`, парсит HTML и CSS в DOM и CSSOM, строит Render Tree, выполняет layout, окрашивает элементы и объединяет слои, при этом скрипты блокируют парсинг, а CSS — рендеринг, с атрибутами `async` и `defer` для управления загрузкой скриптов.
;;;;

Как происходит работа с WebSocket на фронте. Как обрабатывать данные.?
????
URL WebSocket хранится в переменной, подменяется при сборке через конфиг (например, YAML). Подключаем WebSocket, сохраняем в хранилище, подписываемся на события (onError, onMessage) и обрабатываем данные.
;;;;

Как работает position. sticky.?
????
**Элемент с `position: sticky` фиксируется на экране при прокрутке и не выпадает из видимой области, пока родительский контейнер находится в зоне видимости. Работает, если родитель имеет `position: relative`, `fixed` или `absolute`. Элемент остается в потоке документа и требует указания свойств `top`, `bottom`, `left` или `right`. Контекст `overflow: auto` может влиять на поведение sticky, обеспечивая "прилипание" элемента внутри прокручиваемого контейнера.**
;;;;

Как реализовать жизненный цикл в функциональных компонентах React.?
????
Функциональные: useEffect с пустым массивом (монтирование), с зависимостями (обновление), возвращаемая функция (очистка).
;;;;

Как реализовать принцип открытости.закрытости в React.?
????
- Расширять компоненты через пропсы или HOC, не изменяя их код.
;;;;

Как реализуется инкапсуляция в ООП.?
????
**Инкапсуляция** в ООП реализуется через скрытие внутренней логики объекта и предоставление доступа к нему только через публичные методы. (`Например, метод `start()` у кофемашины запускает процесс, не раскрывая детали реализации.`) Данные могут быть скрыты с помощью приватных переменных и методов, либо через замыкания, либо с использованием синтаксиса `#` в классах.
;;;;

Как реализуется конкурентность в JavaScript.?
????
**JavaScript использует однопоточную модель, где конкурентность достигается через асинхронные механизмы, такие как колбэки, промисы и `async/await`; промисы помещаются в Microtask Queue, а задачи от `setTimeout` и `setInterval` в Macro Task Queue; Event Loop управляет Call Stack, обрабатывает задачи из очередей и взаимодействует с Render Queue для обновления интерфейса.**
;;;;

Как сверстать чекбокс с состоянием включено.выключено, аналогичный примеру, с использованием React и CSS.?
????
**Как сверстать кастомный чекбокс с состоянием вкл/выкл на React и CSS (разговорный стиль, как на собеседовании):**

---

### **1. Основная идея:**  
Чтобы создать кастомный чекбокс, мы **скрываем стандартный `<input type="checkbox">`** и стилизуем `<label>` или `<div>`, управляя состоянием через `useState`.  

---

### **2. Пример кода:**  

#### **React + CSS (без использования `<input>`):**  
```tsx
import { useState } from 'react';

const CustomCheckbox = ({ label }) => {
    const [isChecked, setIsChecked] = useState(false);

    const toggle = () => {
        setIsChecked(prev => !prev);
    };

    return (
        <div className="checkbox-container" onClick={toggle} tabIndex={0} role="checkbox" aria-checked={isChecked}>
            <div className={`checkbox ${isChecked ? 'checked' : ''}`}>
                {isChecked && <span className="checkmark">✔</span>}
            </div>
            <span className="checkbox-label">{label}</span>
        </div>
    );
};
```

#### **CSS:**  
```css
.checkbox-container {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    user-select: none;
}

.checkbox {
    width: 24px;
    height: 24px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.checkbox.checked {
    background: #3b82f6; /* Цвет при включении */
    border-color: #3b82f6;
}

.checkmark {
    color: white;
    font-size: 14px;
}

.checkbox-label {
    font-size: 16px;
}
```

---

### **3. Как это работает?**  
- **Состояние:**  
  Используем `useState` для хранения `isChecked` (вкл/выкл).  

- **Клик:**  
  При клике на контейнер вызывается `setIsChecked(prev => !prev)`, обновляя состояние.  

- **Стили:**  
  - Круглый чекбокс (`border-radius: 50%`).  
  - Галочка появляется только если `isChecked = true`.  
  - Цвет фона и границы меняются при переключении.  

- **Доступность:**  
  - `role="checkbox"` и `aria-checked` делают элемент доступным для скринридеров.  
  - `tabIndex={0}` позволяет фокусироваться на чекбоксе с клавиатуры.  

---

### **4. Альтернатива с `<input type="checkbox">`:**  
Если нужно сохранить нативный функционал (например, формы):  
```tsx
const CustomCheckbox = ({ label }) => {
    const [isChecked, setIsChecked] = useState(false);

    return (
        <label className="custom-checkbox">
            <input
                type="checkbox"
                checked={isChecked}
                onChange={(e) => setIsChecked(e.target.checked)}
            />
            <span className={`checkbox ${isChecked ? 'checked' : ''}`}>
                {isChecked && <span className="checkmark">✔</span>}
            </span>
            <span className="checkbox-label">{label}</span>
        </label>
    );
};
```

#### **CSS:**  
```css
.custom-checkbox input {
    display: none;
}

.checkbox {
    width: 24px;
    height: 24px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
}

.checkbox.checked {
    background: #3b82f6;
    border-color: #3b82f6;
}
```

---

### **5. Почему так?**  
- **Flex-контейнер:** Выравниваем чекбокс и текст горизонтально.  
- **Скрытие `<input>`:** Чтобы полностью контролировать внешний вид.  
- **Галочка через `✔`:** Простой способ, но можно использовать SVG или иконки.  
- **Без `:focus` не обойтись:** Добавьте стили для фокуса (например, `outline: 2px dashed #3b82f6`).  

---

### **6. Частые ошибки и как избежать:**  
1. **Забыть про `aria-checked` и `role`:**  
   - Решение: Добавьте `role="checkbox"` и `aria-checked={isChecked}`.  

2. **Не обновить состояние при нажатии на label:**  
   - Решение: Убедитесь, что `onChange` или `onClick` работают корректно.  

3. **Плохая доступность:**  
   - Решение: Добавьте `tabIndex={0}` и обработку клавиш (например, `onKeyDown`).  

4. **Стили не применяются при `isChecked`:**  
   - Решение: Проверьте условия в `className` и CSS-классы.  

---

### **7. Как сделать анимацию включения/выключения?**  
Добавьте плавные переходы в CSS:  
```css
.checkbox {
    transition: background 0.3s ease, border-color 0.3s ease;
}
```

---

### **8. Кратко слово в слово для собеседования:**  
Кастомный чекбокс в React создаётся через `useState` и стилизованный `<div>` или `<label>`. Управляем состоянием `isChecked`, переключая его по клику. В CSS стилизуем элемент под круглый чекбокс, добавляем галочку через `✔` или SVG. Для доступности указываем `role="checkbox"` и `aria-checked`. Альтернатива с `<input type="checkbox">` скрывает нативный чекбокс, сохраняя семантику. Используем `flex` для выравнивания, `transition` для анимации. Основные ошибки: отсутствие доступности и неправильное обновление состояния.
;;;;

Как скопировать объект.?
????
**Поверхностное копирование**: используется, когда объект не содержит вложенных объектов: - `Object.assign` — `Object.assign({}, originalObject)` - Оператор расширения (spread) — `{ ...originalObject }`

**Глубокое копирование**: используется для объектов с вложенными объектами: - `JSON.parse(JSON.stringify(originalObject))` — простой, но может терять методы и undefined. - `structuredClone(originalObject)` — современный метод, который сохраняет методы и не теряет свойства.
;;;;

Какие HTTP-методы знаешь. Чем отличается GET от POST.?
????
HTTP-методы - это способы взаимодействия клиента с сервером, где GET используется для получения данных через URL-параметры, а POST - для безопасной отправки данных в теле запроса, при этом существуют также PUT, PATCH, DELETE, HEAD и OPTIONS для различных операций с ресурсами.

PUT - полная замена ресурса целиком, PATCH - частичное обновление, DELETE - удаление ресурса, HEAD - получение только заголовков без тела, OPTIONS - запрос информации о возможных методах и настройках сервера для конкретного эндпоинта.
;;;;

Какие utility types в TypeScript знаешь.?
????
**Utility types**  — это встроенные типы, которые помогают модифицировать существующие типы.

Omit — исключение свойств, 
Pick — выбор свойств, 
Partial — делает свойства необязательными, 
Required — делает обязательными, 
ReturnType — для типизации возврата функции, 
Record — для типизации ключей-значений объекта. (Частый поиск по ключу, необходимость быстрого доступа, статические справочники, кэширование результатов),
ReadOnly — делает свойства объекта только для чтения
;;;;

Какие виды хранилищ есть в браузере. В чём разница.?
????
В браузере есть несколько видов хранилищ:

1. **IndexedDB**: асинхронная база данных, позволяющая хранить сложные объекты и большие объемы данных, что делает её подходящей для приложений с высоким объемом данных.
    
2. **LocalStorage**: хранит строки (объем 2-5 МБ), данные сохраняются до удаления и доступны во всех открытых вкладках.
    
3. **SessionStorage**: хранит строки, данные доступны только в текущей вкладке и очищаются при закрытии вкладки.
    
4. **Cookies**: хранят строки (максимум 4 КБ), передаются в заголовках HTTP-запросов, имеют атрибуты (HttpOnly, Secure, SameSite) для безопасности; обычно используются для хранения токенов.
;;;;

Какие есть способы объявления функций и их отличия.?
????
1. **Function Declaration (Объявление функции)**:
    
    - Хостится, можно вызывать до объявления; имеет доступ к `arguments`; `this` устанавливается при вызове; можно использовать как конструктор.
    
2. **Function Expression (Функциональное выражение)**:
    
    - Не хостится, ошибка при вызове до инициализации; также имеет доступ к `arguments`; `this` устанавливается при вызове; нельзя использовать как конструктор.
    
3. **Arrow Function (Стрелочная функция)**:
    
    - Не хостится, ошибка при вызове до инициализации; не имеет `arguments`; `this` наследуется из родительской области видимости; нельзя использовать как конструктор.
;;;;

Какие значения position используешь. Опиши их особенности.?
????
**Значения свойства `position`: `static` - значение по умолчанию, элементы располагаются в порядке обычного потока; `relative` - позиционирование относительно исходного места, не влияющее на другие элементы; `absolute` - позиционирование относительно ближайшего позиционированного родителя или окна; `fixed` - фиксированное относительно окна браузера; `sticky` - работает как `relative`, пока не прокрутится до заданного положения, затем ведёт себя как `fixed`; `inherit` - наследует значение от родителя.**
;;;;

Какие препроцессоры CSS вы знаете и в чем их основные преимущества.?
????
- Я знаю Sass, LESS и Stylus. Их основные преимущества включают поддержку переменных, вложенности и функций, что упрощает управление стилями. На нашем проекте я использую styled-components, который не является препроцессором, а библиотекой CSS-in-JS, позволяющей писать стили непосредственно в JavaScript.

Дополнение: styled-components не использует традиционные препроцессоры, так как базируется на JavaScript для генерации стилей динамически
;;;;

Какие типы данных есть в JavaScript.?
????
##### JavaScript имеет 7 примитивных типов (number, string, boolean, undefined, null, symbol, bigint) и 1 ссылочный тип object, который включает массивы и функции, причем примитивы копируются по значению, а объекты - по ссылке.
;;;;

Какие фазы событий есть в DOM.?
????
В DOM есть три фазы обработки событий:

1. **Фаза захвата (capturing)**: событие проходит от корневого элемента документа (document) к целевому элементу.
2. **Целевая фаза (target)**: событие достигает целевого элемента, на котором произошло действие.
3. **Фаза всплытия (bubbling)**: событие всплывает обратно к корню от целевого элемента, позволяя родительским элементам реагировать на него.
;;;;

Какие хуки жизненного цикла используются в функциональном React.?
????
Функциональные: useEffect с пустым массивом (монтирование), с зависимостями (обновление), возвращаемая функция (очистка).
;;;;

Какие хуки ты знаешь.?
????
Самые используемые: useState, useEffect, useLayoutEffect, useMemo, useCallback, useRef, useReducer. На работе использовал useRef для привязки к элементам и манипуляций с ними.
;;;;

Какой опыт работы с Git. Настраивал ли линтеры или хуки. husky eslint?
????
### Опыт работы с Git

- Использование Git для контроля версий позволяет отслеживать изменения в коде, совместно работать над проектами и управлять ветками.
- Являюсь опытным пользователем Git и умею выполнять различные операции, такие как коммиты, слияния, перемотки и `git rebase`.

### Настройка линтеров

**ESLint** — это инструмент для анализа кода JavaScript, который помогает находить и устранять проблемы с кодом. Вот основные шаги для его настройки:

1. **Установка ESLint**: Сначала установим ESLint:
    
    ```bash
    npm install eslint --save-dev
    ```
    
2. **Инициализация ESLint**: После установки вы можете инициализировать конфигурацию ESLint:
    
    ```bash
    npx eslint --init
    ```
    
    Следуйте инструкциям на экране для выбора параметров конфигурации.
    
3. **Создание конфигурационного файла**: Вы можете создать или отредактировать файл `.eslintrc.js`, чтобы настроить правила. Например:
    
    ```javascript
    module.exports = {
        "env": {
            "browser": true,
            "es2021": true
        },
        "extends": "eslint:recommended",
        "parserOptions": {
            "ecmaVersion": 12
        },
        "rules": {
            "semi": ["error", "always"],
            "quotes": ["error", "single"]
        }
    };
    ```
    

### Настройка хуков с Husky

**Husky** — это инструмент, который позволяет настраивать Git хуки, чтобы запускать заданные скрипты при определенных событиях, например, перед коммитом или при выполнении `push`.

1. **Установка Husky**: Установите Husky:
    
    ```bash
    npm install husky --save-dev
    ```
    
2. **Инициализация Husky**: Инициализируйте Husky в вашем проекте:
    
    ```bash
    npx husky install
    ```
    
3. **Создание хуков**: После инициализации вы можете добавлять хуки. Например, чтобы добавить хук для запуска ESLint перед коммитом:
    
    ```bash
    npx husky add .husky/pre-commit "npx eslint ."
    ```
    

### Заключение

Теперь перед каждым коммитом будет автоматически запускаться ESLint, который проверит ваш код на наличие ошибок по установленным правилам. Это помогает поддерживать код чистым и соответствующим стандартам.

Если у вас есть конкретные вопросы по этой теме или вы хотите разобраться с чем-то более детально, дайте знать!
;;;;

Когда оправдано использовать useCallback.?
????
useCallback оправдан, когда функция передаётся как пропс в мемоизированный компонент (React.memo) или используется в useEffect как зависимость, чтобы избежать лишних рендеров. Если функция статическая, её лучше вынести из компонента.
;;;;

Можешь привести пример блочных и строчных тегов HTML.?
????
### Блочные теги
**Блочные теги** обозначают элементы, которые занимают всю ширину родительского элемента и начинаются с новой строки. Они часто используются для оформления структуры страницы.

1. `<div>` — блочный контейнер для группировки элементов.
2. `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`, `<h6>` — заголовки различных уровней.
3. `<p>` — абзац текста.
4. `<ul>`, `<ol>` — маркированный и нумерованный списки соответственно.
5. `<blockquote>` — блок цитаты.
6. `<header>` — определяет заголовок документа или секции.
7. `<footer>` — определяет нижний колонтитул документа или секции.

### Строчные теги
**Строчные теги** занимают только необходимое пространство в строке и не начинают новую строку. Они используются для оформления отдельных частей текста.

1. `<span>` — общий контейнер для строчных элементов.
2. `<a>` — ссылка (гиперссылка).
3. `<strong>` — важный текст (обычно отображается жирным).
4. `<em>` — выделенный текст (обычно отображается курсивом).
5. `<img>` — встроенное изображение.
6. `<small>` — мелкий текст.
7. `<br>` — перенос строки.
;;;;

Можешь рассказать, что такое код состояния ответа сервера и назвать по одному-два из каждой категории.?
????
Коды состояния ответов сервера — это часть протокола HTTP, который используется для обозначения результата выполнения клиентского запроса. Вот основные коды состояния, которые вы упомянули, с кратким описанием:

### Информационные коды (1xx)

- **100 Continue**: Сервер получил начальную часть запроса и клиент может продолжать отправку остальной части запроса.

### Успешные коды (2xx)

- **200 OK**: Запрос выполнен успешно. Это самый распространённый код состояния для успешных HTTP-запросов.
- **201 Created**: Запрос выполнен успешно, и в результате был создан новый ресурс.
- **204 No Content**: Запрос выполнен успешно, но нет возвращаемого содержимого. Используется, например, для удаления ресурса.

### Код состояния клиента (4xx)

- **400 Bad Request**: Сервер не может обработать запрос из-за неправильного синтаксиса. Клиент должен исправить запрос.
- **401 Unauthorized**: Запрос требует аутентификации. Клиент не предоставил необходимые данные для аутентификации.
- **403 Forbidden**: Сервер понял запрос, но отказывается его выполнять из-за недостаточных прав доступа у клиента.
- **404 Not Found**: Запрашиваемый ресурс не найден на сервере. Это может происходить, если запрашивается несуществующий URL.

### Серверные ошибки (5xx)

- **500 Internal Server Error**: Общая ошибка сервера, когда сервер столкнулся с неожиданной ситуацией, которая помешала ему выполнить запрос.
- **502 Bad Gateway**: Сервер выступал в роли прокси или шлюза и получил недопустимый ответ от upstream-сервера.
- **503 Service Unavailable**: Сервер временно недоступен (например, из-за перегрузки или проведения обслуживания).
;;;;

Можно ли использовать useEffect без массива зависимостей. Почему это не рекомендуется.?
????
Можно, но useEffect будет вызываться на каждый рендер, что может привести к ненужным запросам или операциям, снижая производительность.
;;;;

Объясни концепцию прототипного наследования.?
????
**Концепция прототипного наследования в JavaScript** заключается в том, что объекты могут наследовать свойства и методы от других объектов через прототипы.

Когда вы создаете объект с помощью функции-конструктора, он получает доступ к методам и свойствам, определенным в его прототипе. Если свойство или метод не найдено у самого объекта, JavaScript ищет его в цепочке прототипов.
;;;;

Опиши путь отрисовки страницы (Critical Rendering Path).?
????
1. **Парсинг HTML**:  
    Браузер парсит HTML-код и создает **DOM** (Document Object Model).
    
2. **Парсинг CSS**:  
    Браузер парсит CSS и формирует **CSSOM** (CSS Object Model).
    
3. **Создание Render Tree**:  
    Объединяются DOM и CSSOM в **Render Tree**, который содержит только видимые элементы.
    
4. **Процесс Layout**:  
    Выполняется **Layout** — вычисление размеров и позиций элементов на странице.
    
5. **Процесс Painting**:  
    **Painting** — заливка цветов и отрисовка шрифтов для видимых элементов.
    
6. **Композиция**:  
    На финальном этапе происходит **Composition**, где слои объединяются в одно изображение для отображения в браузере.
    

### Дополнительно

JavaScript может подгружаться асинхронно и выполняется в процессе, что может повлиять на эти этапы и блокировать отрисовку, если будет выполнен до завершения парсинга HTML.
;;;;

По каким причинам компонент в React может перерендериться.?
????
Рендер происходит при:

1. Изменении состояния (useState).
2. Изменении пропсов.
3. Рендере родительского компонента.
4. Изменении ключей.  
    Функции/объекты создают новые ссылки, но не триггерят рендер, если не используются в зависимостях useEffect.
;;;;

Почему var лучше не использовать, в чем разница с let и const.?
????
`var` лучше не использовать, поскольку он имеет функциональную область видимости и подвержен хостингу, что может приводить к неопределённому поведению. В отличие от него, `let` и `const` имеют блочную область видимости, что делает код более предсказуемым. При этом `const` не позволяет переопределять примитивы, но позволяет изменять содержимое объектов.
;;;;

Почему теряется контекст в функции, возвращаемой из объекта. Как исправить.?
????
Контекст теряется, потому что `this` определяется местом вызова, а не объявления. Если функция возвращается из объекта и вызывается отдельно, `this` ссылается на `window` (или `undefined` в strict mode). Исправляют:

1. `bind()` — привязывает `this` заранее.
2. Стрелочные функции — берут `this` из внешнего контекста.
3. `call()`/`apply()` — задают `this` при вызове.
4. Сохранение `this` во внешней переменной (`self = this`).
;;;;

Работал ли с микрофронтендами?
????
###### Микрофронтенды — это архитектурный подход, при котором веб-приложение разбивается на независимые куски. Каждая команда может работать над своей частью интерфейса, используя разные технологии.
###### Преимущества микрофронтендов:

- **Модульность**: Позволяет командам работать независимо над различными частями приложения.
- **Гибкость технологий**: Возможность выбора разных технологий и фреймворков для каждой части.
- **Ускорение разработки**: Команды могут разрабатывать функции параллельно без зависимости друг от друга.
- **Постепенные обновления**: Можно обновлять части приложения поэтапно.

###### Недостатки:

- **Сложность интеграции**: Могут возникать проблемы с совместимостью между микрофронтендами.
- **Производительность**: Большое количество ресурсов может замедлить загрузку страницы.
- **Трудности с тестированием**: Необходимо протестировать взаимодействие всех частей.
- **Увеличенные затраты на DevOps**: Требуется больше усилий для настройки инфраструктуры.

###### Как бороться с недостатками:

- **Стандартизация**: Введение общих стандартов разработки и интеграции.
- **Оптимизация загрузки**: Использование lazy loading и других методов для улучшения производительности.
- **Автоматизация тестирования**: Настройка CI/CD для автоматического тестирования микрофронтендов.
- **Документация**: Поддержание актуальной документации и проведение обучений для команд.
;;;;

Расскажи подробнее про хук useEffect. Для чего нужен?
????

;;;;

Расскажи подробнее про хук useEffect.?
????
**`useEffect`** — это хук в React, позволяющий выполнять побочные эффекты в функциональных компонентах. Он принимает две вещи:

1. **Функцию: Эта функция выполняется после рендера компонента. Она может использоваться для получения данных, подписки на события и т. д.
    
2. **Массив зависимостей**: Указывает, когда выполнять эффект:
    
    - **Пустой массив (`[]`)**: Эффект выполняется **один раз при монтировании** компонента.
    - **Без массива**: Эффект выполняется **на каждом рендере**.
    - **С зависимостями**: Эффект выполняется при изменении указанных переменных.

Если функция возвращает другую функцию, это будет **функция очистки**, которая выполняется перед следующим вызовом эффекта или при размонтировании компонента.

Для чего используют:
1. Получение данных из API
2. Подписка на события (подписки на события окна, такие как изменение размера)
3. Таймер
4. Обновление заголовков документа (Счетчик)
;;;;

Расскажи про Event Loop.?
????
Event Loop — это механизм в JavaScript, который управляет выполнением кода, асинхронными задачами и событиями. Он работает так:  
1. Синхронные задачи выполняются сразу в стеке вызовов.  
2. Асинхронные операции (например, `setTimeout`, `fetch`) передаются в Web API браузера.  
3. После завершения они попадают в очередь:  
   - Микрозадачи (`Promise`, `MutationObserver`) → очередь микрозадач.  
   - Макрозадачи (`setTimeout`, `setInterval`) → очередь макрозадач.  
4. Event Loop проверяет стек вызовов. Если он пуст, он сначала обрабатывает все микрозадачи, потом одну макрозадачу и повторяет цикл.  

Это позволяет JS работать в однопоточном режиме, не блокируя интерфейс. Например, `Promise.then` сработает раньше `setTimeout`, даже с нулевой задержкой.
;;;;

Расскажи про useRef.?
????
`useRef` — это хук в React, который позволяет создавать ссылку на элемент или значение, которое сохраняется между рендерами компонента.
1. useRef создаёт ссылку на DOM-элемент или хранит значение, не вызывающее перерендер. 
2. Используется для неконтролируемых инпутов, изменения размеров, хранения мутабельных данных. 
3. (Примеры: привязка к свайперу для управления, отслеживание элемента для анимаций, хранение интервалов/таймеров.)
;;;;

Расскажи про жизненный цикл компонента в React. Какие бывают методы жизненного цикла.?
????
##### Жизненный цикл: монтирование, обновление, размонтирование. Классовые: componentDidMount, componentDidUpdate, componentWillUnmount. Функциональные: useEffect с пустым массивом (монтирование), с зависимостями (обновление), возвращаемая функция (очистка).
;;;;

Расскажи про типы any, unknown, never. Для чего они нужны.?
????
- **any** отключает проверку типов, что делает его небезопасным и может привести к ошибкам, так как позволяет использовать любые значения без проверки.
- **unknown** безопаснее, требует сужения типа перед использованием, что заставляет проверять значения перед вызовом методов или обращением к свойствам.
- **never** используется для функций, которые никогда не возвращают значение (например, из-за бесконечного цикла или выбрасывания ошибки), и также применяется для отфильтровки типов в утилити-типах и конструкциях `switch` с `enum`.
;;;;

Реализовать самописный filter для массива.?
????

;;;;

Чем отличается Flex от Grid.?
????
**Flexbox используется для однородного распределения элементов по одной оси (главной и побочной) с помощью свойств `justify-content` и `align-items`, в то время как Grid позволяет создавать сложные сетки с двумя измерениями, задавая строки и колонки через `grid-template-rows` и `grid-template-columns`; Flexbox подходит для простых макетов, а Grid — для более комплексных компоновок**
;;;;

Чем отличается hasOwnProperty от оператора in.?
????
`hasOwnProperty` проверяет наличие свойства только в самом объекте, игнорируя прототипы. Оператор `in` проверяет свойства в объекте и его прототипах.
;;;;

Чем отличается Promise.all от Promise.allSettled.?
????
- **Promise.all**: возвращает `reject`, если хотя бы один из переданных промисов завершился с ошибкой, игнорируя остальные.
- **Promise.allSettled**: возвращает массив объектов с полями `status` (может быть `fulfilled` или `rejected`) и данными `value` или `reason`, независимо от успешности или неудачи промисов.

Таким образом, **Promise.all** останавливается при первой ошибке, а **Promise.allSettled** всегда возвращает результаты всех промисов.
;;;;

Чем отличается RTK от Redux.?
????
**RTK (Redux Toolkit)** отличается от классического Redux следующими способами:

1. **Упрощенный код**: RTK содержит встроенные действия и утилиты, что значительно сокращает объем boilerplate-кода.
2. **Прямое изменение состояния**: позволяет мутировать состояние напрямую с помощью Immer, который под капотом создает неизменяемые копии.
3. **Поддержка `createAsyncThunk`**: облегчает работу с асинхронными операциями, упрощая обработку промисов.

В классическом Redux требуется больше ручного кода и управление состоянием.
;;;;

Чем отличается undefined от null.?
????
**`undefined`** и **`null`** — это два разных типа данных в JavaScript:

1. **null**:
    - Явное указание на отсутствие значения.
    - Устанавливается разработчиком, чтобы показать, что значение намеренно отсутствует.
    - `typeof null` возвращает `"object"` (что является исторической ошибкой).

2. **undefined**:
    - Указывает на неопределенное значение.
    - Возникает, когда переменная не была инициализирована или функция ничего не возвращает.
    - `typeof undefined` возвращает `"undefined"`.

Таким образом, `null` используется для явного указания на отсутствие значения, а `undefined` обычно означает, что значение не было задано.
;;;;

Чем отличается unknown от any.?
????
- **`any`**:
    
    - Отключает проверку типов, позволяя присваивать любое значение.
    - Использование `any` может привести к ошибкам, так как TypeScript не предоставляет никаких гарантий.
- **`unknown`**:
    
    - Является безопасным типом, который требует подтверждения типа (например, с помощью type guards или `typeof`) перед использованием.
    - Позволяет избежать ошибок, связанных с неверными предположениями о типе.


Используйте `any`, когда нужно отключить проверку типов, и `unknown` для безопасной обработки значения с обязательной проверкой типа перед его использованием.
;;;;

Чем отличается useEffect от useLayoutEffect.?
????
##### useEffect — асинхронный, не блокирует рендер. useLayoutEffect — синхронный, выполняется до отрисовки и блокирует рендер
;;;;

Чем отличается useMemo от useCallback.?
????
**Разница между `useMemo` и `useCallback`**:

- **`useMemo`**: используется для мемоизации значений. Он минимизирует результаты сложных вычислений, чтобы не пересчитывать их при каждом рендере. Например, если у вас есть тяжелая функция, вычисляющая данные, вы можете обернуть её в `useMemo`.
    
- **`useCallback`**: используется для мемоизации функций. Он предотвращает пересоздание функции при каждом рендере, что особенно полезно при передаче колбеков в мемоизированные компоненты. Это позволяет избежать лишних рендеров.
    

Применение:

- `useMemo` для сложных вычислений.
- `useCallback` для передачи функций и исключения лишних зависимостей в `useEffect`.
;;;;

Чем отличаются localStorage и sessionStorage.?
????
`localStorage` хранит данные без времени действия и доступен во всех вкладках одного домена, в то время как `sessionStorage` хранит данные только на время текущей сессии и доступен только в одной вкладке.
;;;;

Чем отличаются Set и Map. Чем Map отличается от объекта.?
????
- **`Set`** хранит только **значения** (каждое значение должно быть уникальным).
- **`Map`** хранит **ключи** любого типа и соответствующие им значения.
###### `Порядок:`

- **Гарантируется**: `Array`, `Set`, `Map` (сохраняют порядок добавления).
- **Не гарантируется**: `Object` (порядок не определен).
---

В `Map` ключами могут быть любые типы данных, включая функции и объекты, в то время как в объектах ключами могут быть только строки или символы.
###### Методы `Map`

- **`set(key, value)`**: Добавляет или обновляет запись.
- **`get(key)`**: Возвращает значение по указанному ключу или `undefined`, если ключа нет.
- **`has(key)`**: Проверяет наличие ключа в коллекции.
;;;;

Чему равен this в function declaration и стрелочной функции.?
????
1. **Function Declaration**:
    - В глобальном контексте `this` в обычной функции (`function declaration`) указывает на глобальный объект:
        - В браузере это `window`.
        - В Node.js это `global`.
    - В строгом режиме (`'use strict'`) `this` будет равен `undefined` в обычной функции.
2. **Стрелочная функция**:
    - В стрелочных функциях `this` **не привязывается** к самой функции, а **наследуется** из внешнего контекста (где была объявлена стрелочная функция). Это значит, что `this` в стрелочной функции всегда будет ссылаться на `this` родительской функции или объекта.
;;;;

Что происходит при вызове функции с new.?
????
**При вызове функции с `new` создаётся новый пустой объект, `this` привязывается к этому объекту, и функция-конструктор заполняет его свойства; прототип нового объекта устанавливается на `Function.prototype` (т.е. `Test.prototype` в случае конструктора `Test`); в итоге возвращается созданный объект.**
;;;;

Что такое Content Security Policy и как это можно настроить.?
????
Content Security Policy - это механизм защиты веб-приложений, который позволяет контролировать источники загрузки контента и предотвращать межсайтовые скриптовые атаки путем настройки политик безопасности через HTTP-заголовки.
;;;;

Что такое CSRF и как защититься.?
????
**CSRF (Cross-Site Request Forgery)** — это атака, при которой злоумышленник отправляет запрос от имени пользователя без его ведома, подделывая действия, которые тот мог бы выполнить.

###### Методы защиты от CSRF:

1. **CSRF-токены**: Использовать уникальные токены в скрытых полях форм или заголовках запросов, которые проверяются на стороне сервера. Это позволяет удостовериться, что запрос действительно инициирован пользователем.

2. **SameSite для кук**: Установить атрибут `SameSite` для кук, что ограничит их отправку при кросс-доменных запросах. Это снижает риск несанкционированных действий.
;;;;

Что такое event loop, макротаски и микротаски.?
????
Event Loop — это событийный цикл в JavaScript, который управляет выполнением кода, асинхронными задачами и событиями. Он работает так:  
1. Синхронные задачи выполняются сразу в стеке вызовов.  
2. Асинхронные операции (например, `setTimeout`, `fetch`) передаются в Web API браузера.  
3. После завершения они попадают в очередь:  
   - Микрозадачи (`Promise`, `MutationObserver`) → очередь микрозадач.  
   - Макрозадачи (`setTimeout`, `setInterval`) → очередь макрозадач.  
4. Event Loop проверяет стек вызовов. Если он пуст, он сначала обрабатывает все микрозадачи, потом одну макрозадачу и повторяет цикл.  

Это позволяет JS работать в однопоточном режиме, не блокируя интерфейс. Например, `Promise.then` сработает раньше `setTimeout`, даже с нулевой задержкой.

**Макротаски** – это задачи, которые обрабатываются в основном потоке выполнения JavaScript. Каждая макротаска занимает одно полное выполнение потока, и управление по завершении макротаски передается обратно в событие основного потока.


**Микротаски** – это более мелкие задачи, которые имеют более высокий приоритет по сравнению с макротасками. Они выполняются сразу после завершения текущего скрипта, но перед обработкой следующей макротаски.
;;;;

Что такое FSD. Как используешь.?
????
**Feature-Sliced Design (FSD)** — это архитектурный подход, который делит проект на слои (entities, features, pages, widgets, API), используя модульность и инверсию зависимостей. Я выбирал бы FSD для сложных проектов, таких как интернет-магазины, поскольку он обеспечивает масштабируемость и тестируемость, хотя имеет высокую точку входа. FSD придерживается одностороннего потока данных (экшн → диспатч → store → UI), что делает его более предсказуемым и упрощает поддержку по сравнению с традиционными подходами, такими как MVC.
;;;;

Что такое Generic в TypeScript.?
????
**Generic** - это способ, который позволяет динамически типизировать функции, компоненты и типы. Generics используются, когда заранее неизвестно, с каким типом данных будет работать разработчик. 


Например:
    
    <T> — тип,
    <K> — ключ,
    <V> — значение (Value),
    <E> — элемент (Element).
;;;;

Что такое High-Order Components (HOC).?
????
**High-Order Component (HOC)** — это функция в React, которая принимает компонент, добавляет к нему логику или поведение и возвращает новый компонент.
;;;;

Что такое React Reconciliation.?
????
**Reconciliation** — это процесс в React, который отвечает за оптимизацию обновлений компонентов и их представлений в виртуальном DOM. Когда состояние или пропсы изменения, React сравнивает текущее дерево виртуального DOM с новым и определяет, какие изменения необходимо внести в реальный DOM.

###### Примеры:

- При использовании `useState` несколько раз подряд React _объединяет_ эти изменения и рендерит компонент только один раз, минимизируя количество перерисовок и обновлений в реальном DOM.
- React использует алгоритм **diffing**, чтобы эффективно находить и применять изменения, что позволяет избежать лишних операций и повышает производительность приложения.
;;;;

Что такое React.memo.?
????
**React.memo** — это высокоуровневый компонент (HOC), который мемоизирует функциональные компоненты, предотвращая их перерендер, если пропсы не изменились. Он оборачивает компонент и сравнивает предыдущие и текущие пропсы; если они равны, повторный рендер не происходит. Для лучшей оптимизации рекомендуется использовать `React.memo` вместе с `useCallback`, чтобы избежать изменения ссылок на функции-пропсы и минимизировать ненужные рендеры.
;;;;

Что такое rest-оператор.?
????
- Собирает остаточные аргументы функции в массив (...args) или используется для деструктуризации.
;;;;

Что такое SOLID-принципы. Расскажи про них.?
????
##### **SOLID-принципы** — это набор пяти основных принципов объектно-ориентированного программирования.
1. S:  Принцип единственной ответственности - класс имеет одну ответственность.
2. O:  Принцип открытости/закрытости - открыт для расширения, закрыт для модификации.
3. L:  Принцип подстановки Лисков - объекты подтипов заменяемы без изменения поведения.
4. I:  Принцип разделения интерфейса - много узких интерфейсов лучше, чем один общий
5. D: Принцип инверсии зависимостей - высокоуровневые модули зависят от абстракций, не от низкоуровневых.
;;;;

Что такое spread-оператор.?
????
Распаковывает элементы массива или свойства объекта для копирования или расширения. Например, [...arr] копирует массив, {...obj} — объект.
;;;;

Что такое this в JavaScript.?
????
`this` — это специальное ключевое слово в JavaScript, которое ссылается на контекст, в котором выполняется текущий код.
;;;;

Что такое Virtual DOM. Зачем нужен.?
????
###### Virtual DOM — это механизм React, который создаёт виртуальную копию DOM. При обновлении состояния React сначала меняет эту копию, сравнивает её с предыдущей (reconciliation), и обновляет только те элементы, которые изменились. Это ускоряет рендеринг, так как прямая работа с DOM (например, через `document.getElementById().innerHTML`) требует много ресурсов.
;;;;

Что такое WeakMap и WeakSet и зачем нужны.?
????
**WeakMap** и **WeakSet** — это коллекции в JavaScript, которые хранят только ссылки на объекты, и объекты автоматически удаляются из них, если на них нет ссылок, что позволяет предотвращать утечки памяти и оптимизировать использование ресурсов.
;;;;

Что такое XSS-атака и как её предотвратить.?
????
**XSS (Cross-Site Scripting)** — это атака, при которой злоумышленник внедряет вредоносный скрипт в приложение (например, через форму), который затем исполняется в браузере пользователей.

###### Виды XSS:

- **Stored XSS**: скрипт сохраняется на сервере (в базе данных).
- **Reflected XSS**: скрипт отправляется через URL или формы и выполняется немедленно.
- **DOM-based XSS**: скрипт манипулирует содержимым страницы через DOM.

###### Предотвращение XSS:

1. Используйте безопасные методы, такие как `textContent` вместо `innerHTML`.
2. Применяйте санитизацию с помощью библиотек, таких как **DOMPurify**.
3. Настройте **Content Security Policy** (CSP) для ограничения загрузки скриптов.
4. В **React** используйте стандартный JSX, а `dangerouslySetInnerHTML` с осторожностью.
;;;;

Что такое абстракция в ООП.?
????
**Абстракция в ООП** — это принцип, позволяющий скрывать сложные детали реализации и предоставлять простой и понятный интерфейс для взаимодействия с объектами.
- (например, хуки useState, useRef в React).
;;;;

Что такое бандлы и чанки.?
????
Бандл — единый файл (HTML, CSS, JS) для отправки на клиент. Чанки — части бандла, загружаемые по необходимости для оптимизации.
;;;;

Что такое делегирование событий.?
????
**Делегирование событий** — это техника, позволяющая навешивать один обработчик на родительский элемент для обработки событий дочерних элементов, что оптимизирует производительность и позволяет работать с динамически добавленными элементами.
;;;;

Что такое замыкание в JavaScript.?
????
- **Замыкание** — это способность функции запоминать лексическое окружение, в котором она была создана. 
- Так как она имеет ссылку на внешнюю область видимости, в которой она находится
- Это позволяет функции получать доступ к переменным своей внешней функции даже после завершения её выполнения.
;;;;

Что такое мерж и ребейз в Git. Когда их использовать.?
????
**Мерж создает дополнительный коммит, сохраняя полную историю веток, в то время как ребейз переписывает историю, создавая линейный и более чистый вид, поэтому репозиторий лучше использовать для локальных веток; мерж предпочтителен для объединения публичных веток, чтобы избежать конфликтов при форсированном пуше.**
;;;;

Что такое область видимости в JavaScript. Можешь объяснить на примере.?
????
**Область видимости** в JavaScript — это контекст, в котором доступны переменные и функции. Существует три типа:

1. **Глобальная**: переменные, объявленные вне функций, доступны везде.
2. **Функциональная**: переменные, объявленные внутри функции, доступны только в этой функции.
3. **Блочная**: переменные, объявленные с помощью `let` или `const` в блоках (`if`, `for`), доступны только внутри этих блоков.

Пример:

```javascript
var globalVar = 'Глобальная';

function myFunction() {
    var localVar = 'Локальная';
    if (true) {
        let blockVar = 'Блочная';
        console.log(blockVar); // доступна
    }
    console.log(localVar); // доступна
    // console.log(blockVar); // ошибка: не определена
}

myFunction();
console.log(globalVar); // доступна
// console.log(localVar); // ошибка: не определена
```
;;;;

Что такое паттерн Proxy и какие его применения во фронтенде.?
????
Паттерн Proxy связан с перехватом действий. Применяется, например, в Webpack для проксирования запросов, в ленивой загрузке данных (доступ к свойству через объект Proxy), в стейт-менеджерах (MobX), для логирования через Proxy на метод get.
;;;;

Что такое полиморфизм в ООП.?
????
Полиморфизм — возможность заменять методы суперкласса в подклассах. Например, абстрактный класс Person с методом, который переопределяется в классе FrontendDeveloper.
;;;;

Что такое принцип инверсии зависимостей.?
????
**Принцип инверсии зависимостей** говорит о том, что высокоуровневые модули не должны зависеть от низкоуровневых, а оба должны опираться на абстракции. То есть зависимости передаются через интерфейсы, а не жестко привязаны к конкретным реализациям.
;;;;

Что такое промисы. Зачем нужны. Что такое async.await.?
????
**Promise** — это объект, представляющий асинхронную операцию с тремя состояниями (pending, fulfilled, rejected), позволяющий удобно обрабатывать результаты через методы `.then()`, `.catch()`, и `.finally()`, а также облегчая работу с асинхронным кодом с использованием `async/await`.
;;;;

Что такое прототипы в JavaScript.?
????
**Прототип в JavaScript — это объект, связанный с другим объектом, который позволяет наследовать свойства и методы. Прототипное наследование происходит через свойство `[[Prototype]]`, позволяя объекту перенимать свойства от другого через цепочку прототипов; при создании объекта с помощью `new` прототипом становится функция-конструктор, а свойства и методы можно добавлять через свойство `prototype`.**
;;;;

Что такое псевдоэлементы и псевдоклассы. Как их использовал.?
????
Псевдоэлементы  `before, ::after, ::placeholder ` — не отображаются в DOM, используются для стилизации (например, добавления слоя). Псевдоклассы (:hover, :active, :visited) — для интерактивных состояний. Использовал для анимаций, например, аккордеона или вращающихся элементов с остановкой при наведении.
;;;;

Что такое редьюсер.?
????
Редьюсер - это чистая функция, принимающая текущее состояние и экшен, возвращающая новое состояние.
;;;;

Что такое специфичность селекторов.?
????
Специфичность — это вес селектора. Наивысший приоритет у !important, затем инлайн-стили, селекторы по ID, по классу, по тегу. Формула: трехзначное число (ID, классы/псевдоклассы, теги/псевдоэлементы).
;;;;

Что такое тип never в TypeScript.?
????
**never** используется для функций, которые никогда не возвращают значение (например, из-за бесконечного цикла или выбрасывания ошибки), и также применяется для отфильтровки типов в утилити-типах и конструкциях `switch` с `enum`.
;;;;

Что такое хостинг в JavaScript. Что может всплыть, а что нет.?
????
Хостинг — когда переменные или функции "всплывают" и доступны до их объявления. var и function declaration всплывают, но var не инициализируется (значение undefined). let и const всплывают, но без доступа до инициализации (Temporal Dead Zone).
;;;;

